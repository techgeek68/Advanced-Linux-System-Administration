# Bash Shell Scripting

---

**- What is a Shell Script?**
- A shell script is a normal text file that contains a sequence of commands to perform specific tasks. It is a way to automate tasks on a computer by writing a list of commands in a text file and running them as a single script.

**Uses of Shell Scripting**
  - Running or creating programs
  - Automating code compilation
  - Completing batch operations
  - Manipulating files
  - Linking programs together
  - Backing up files
  - Monitoring a system
  - System administration tasks
  - Creating simple applications

---

**Types of Shells**
- Common Unix/Linux shells: 
  - **sh**:  Original shell of UNIX
  - **csh**: C shell
  - **tcsh**:  TENEX C shell
  - **bash**:  Bourne Again Shell (default shell of RHEL)
  - **ksh**: Korn Shell
  - **zsh**: Z shell

---

**Creating and Executing Shell Scripts**
- Shebang (HashBang)
  - The first line of a script file begins with `#!` notation (shebang/hashbang), which indicates which command interpreter processes the script.
  - The shebang line directs the system to execute the script as:  `/usr/bin/bash script.sh`

For Bash scripts, use:
```bash
#!/usr/bin/bash
```

Or alternatively:
```bash
#!/bin/bash
```
> Note:
> - `#!/bin/bash` is the traditional and most portable form (works on most Linux distributions)
> - `#!/usr/bin/bash` works on some systems but less commonly
> - `#!/usr/bin/env bash` is portable across systems but has different security implications


### Making Scripts Executable

A shell script file must have execute permissions to run as a command: 

```bash
chmod u+x helloworld.sh    # User execute permission
chmod a+x helloworld.sh    # All (user, group, other) execute permission
chmod g+x helloworld.sh    # Group execute permission
chmod o+x helloworld.sh    # Other execute permission
```

---

**- Simple Example**
  - Creating a script to check memory and storage: 

```bash
vim sysadmintask.sh
```

Script content:
```bash
#!/usr/bin/bash
lsblk
df -h
free -h
date
```

Execute the script:
```bash
chmod u+x sysadmintask.sh
./sysadmintask.sh
```

---

**Executing Scripts**

Execute a script by: 
  1. **Full path**: `/home/devops/helloworld.sh`
  2. **Relative path**: `./helloworld.sh`
  3. **Script name only** (if in PATH): `helloworld.sh`


**Setting PATH for Scripts**
  - Temporary PATH (current session only)
```bash
PATH=$PATH:/home/devops
# Now scripts in /home/devops can be run by name
helloworld.sh
```

  - Permanent PATH for current user
Edit `~/.bashrc`:
```bash
vim ~/.bashrc
```

  - Add the following line:
```bash
export PATH=$PATH:/home/devops
```

  - Apply changes:
```bash
source ~/.bashrc
```

  - Permanent PATH for all users (system wide)
Edit `/etc/profile` or `/etc/bashrc`:
```bash
vim /etc/profile
```

  - Add:
```bash
export PATH=$PATH:/home/devops
```

> Note: For system wide changes, create a file with `.sh` extension in `/etc/profile.d/` directory (requires root privileges).

---

**Shell Variables and Environment**

**Variable Assignment**
  - Syntax (no spaces around equals sign):
```bash
VARIABLENAME=value
```

Examples:
```bash
COUNT=40
first_name=John
full_name='John Smith'
file1=/tmp/abc
_ID=Training
```

- Variable Naming Rules
  - Can contain uppercase, lowercase letters, digits, and underscore (_)
  - Convention: System variables use uppercase; user defined uses lowercase
  - No spaces around the equals sign

**- Variable Data Types**
  - String Variables
```bash
# With or without quotes (quotes needed if value contains spaces)
bare=This\ string\ escapes\ all\ spaces
string_var='literal string'    # Single quotes (literal)
string_var="expandable string" # Double quotes (allows expansion)
```

  - Numeric Variables
```bash
five=5
ten=10
result=$((five + ten))  # Arithmetic expansion
```

  - Array Variables
```bash
colors=('red' 'green' 'blue')            # Access element (zero based indexing)  

echo ${colors[0]}                        # Output: red
echo ${colors[2]}                        # Output: blue

echo ${colors[@]}                         # Access all elements Output: red green blue

echo ${#colors[@]}                         # Get array lengthOutput: 3            
```

**Variable Expansion (Retrieval)**
  - Use `$` prefix to expand variable value: 
```bash
COUNT=40

echo COUNT                    # Output: COUNT
echo $COUNT                   # Output: 40
echo "Count is $COUNT"        # Output: Count is 40
```


  - Using Curly Braces
    - Use `${VARIABLE}` to delimit variable names when followed by other characters:

```bash
COUNT=40

echo "Repeat $COUNTx"       # Wrong - tries to expand COUNTx
echo "Repeat ${COUNT}x"     # Correct - Output: Repeat 40x
```

**- Unsetting Variables**
```bash
unset variable_name
```

**- Viewing All Variables**
```bash
set | less  # List all variables and functions
env         # List environment variables
```

**- Export Environment Variables**
  - Make a variable available to all programs run from the shell:

```bash
export VARIABLENAME=value
# Or export existing variable
EDITOR=vim
export EDITOR
```

- Important Environment Variables

| Variable | Purpose |
|----------|---------|
| HOME | User's home directory |
| PATH | Directories containing executable commands |
| LANG | Locale encoding and language settings |
| EDITOR | Default text editor |
| PS1 | Shell prompt appearance |
| HISTFILE | Shell history file location |
| HISTFILESIZE | Number of commands to save |
| HISTTIMEFORMAT | Timestamp format for history |


**Configuring Shell Environment**
  - Customizing Command Prompt (PS1)
```bash
# Simple prompt
PS1="bash\$ "

# Detailed prompt with user, host, and directory
PS1="[\u@\h \W]\$ "
```

Prompt special characters:
- `\u`: Username
- `\h`: Hostname (up to first period)
- `\W`: Current directory basename
- `\$`: `#` if root, `$` otherwise


**Example: Changing History Format**
```bash
HISTTIMEFORMAT="%Y-%m-%d %H:%M:%S "

history                # Now shows timestamps
```

- Setting Default Editor

```bash
export EDITOR=vim
```

**Bash Aliases**
  - Create shortcuts for commands:
```bash
alias hello='echo "Hello, this is a long string."'
hello  # Executes the echo command

alias ll='ls -la'  # Common alias
```

- Add aliases to `~/.bashrc` for persistence: 

```bash
vim ~/.bashrc
alias hello='echo "Hello, this is a long string."'
source ~/.bashrc
```

  - Unexporting Variables and Aliases
```bash
# Unexport variable
export -n PS1

# Unset variable or alias
unset variable_name
unalias alias_name
```

---

**Bash Operators**
  - Bash shell scripts support five categories of operators:

**1. Arithmetic Operators**
  - Used for mathematical operations.  Use `$((expression))` syntax:

```bash
# Addition
result=$((10 + 5))  # 15

# Subtraction
result=$((10 - 5))  # 5

# Multiplication
result=$((10 * 5))  # 50

# Division
result=$((10 / 5))  # 2

# Modulus (remainder)
result=$((10 % 3))  # 1

# Exponentiation
result=$((2 ** 3))  # 8

# Compound assignments
num=5
num=$((num + 5))    # 10
num=$((num * 2))    # 20
```

**2. Relational Operators**
  - Compare two values and return true or false:

| Operator | Description | Example |
|----------|-------------|---------|
| `-eq` | Equal to | `[[ 5 -eq 5 ]]` |
| `-ne` | Not equal to | `[[ 5 -ne 3 ]]` |
| `-lt` | Less than | `[[ 3 -lt 5 ]]` |
| `-le` | Less than or equal | `[[ 3 -le 5 ]]` |
| `-gt` | Greater than | `[[ 5 -gt 3 ]]` |
| `-ge` | Greater than or equal | `[[ 5 -ge 5 ]]` |


**3. Logical Operators**
  - Perform logical operations: 

| Operator | Name | Description |
|----------|------|-------------|
| `&&` | Logical AND | Both conditions true |
| `\|\|` | Logical OR | Either condition true |
| `!` | Logical NOT | Negates condition |
| `-a` | AND (test format) | Both conditions true |
| `-o` | OR (test format) | Either condition true |

Examples:
```bash
[[ $age -gt 18 && $status = "active" ]]  # AND
[[ $x -eq 5 || $y -eq 10 ]]              # OR
[[ !  -f /etc/passwd ]]                    # NOT
```

**4. String Operators**
  - Compare string values:

| Operator | Description |
|----------|-------------|
| `=` or `==` | Strings are equal |
| `!=` | Strings are not equal |
| `-z` | String is empty |
| `-n` | String is not empty |

Examples:
```bash
[[ "$string1" = "$string2" ]]
[[ "$string1" != "$string2" ]]
[[ -z "$string" ]]  # True if empty
[[ -n "$string" ]]  # True if not empty
```

**5. File Test Operators**
  - Test file properties: 

| Operator | Description |
|----------|-------------|
| `-b` | Block special file |
| `-c` | Character special file |
| `-d` | Directory exists |
| `-e` | File exists |
| `-f` | Regular file |
| `-r` | File has read permission |
| `-w` | File has write permission |
| `-x` | File has execute permission |
| `-s` | File size > 0 |

Examples:
```bash
[[ -f /etc/passwd ]]      # Is regular file? 
[[ -d /home ]]            # Is directory?
[[ -r $file ]]            # Has read permission?
[[ -x /usr/bin/bash ]]    # Has execute permission? 
[[ !  -f $file ]]          # File does NOT exist?
```

**6. Bitwise Operators**
  - Perform binary operations on bit patterns:

| Operator | Description |
|----------|-------------|
| `&` | Bitwise AND |
| `\|` | Bitwise OR |
| `^` | Bitwise XOR |
| `~` | Bitwise complement |
| `<<` | Left shift |
| `>>` | Right shift |

---

**Input and Output in Bash Scripts**

**- Reading User Input**

**Using `read` Command**

Basic syntax:
```bash
read variable_name
```

Example script:
```bash
#!/usr/bin/bash
echo "How old are you?"
read age
echo "You are $age years old!"
```

**Using `read -p` (Prompt)**

More concise version:
```bash
#!/usr/bin/bash
read -p "How old are you? " age
echo "You are $age years old!"
```

**Reading Multiple Values**

```bash
read -p "Enter name and age: " name age
echo "Name: $name, Age:  $age"
```

**- Output with `echo`**

```bash
echo "Hello, World"           # Print string
echo $variable               # Print variable value

echo "Name: $name"           # String with variable
echo -e "Line1\nLine2"       # Enable interpretation of escapes
echo -n "No newline"         # Suppress trailing newline
```

**- Redirecting Output**

```bash
command > file              # Redirect STDOUT to file
command >> file             # Append STDOUT to file
command 2> error. log        # Redirect STDERR to file
command > output.log 2>&1   # Redirect both STDOUT and STDERR
echo "message" >&2          # Send to STDERR
```

**Conditional Statements**

**Test Command and Conditions**
  - Use `test` or `[[ ]]` syntax to evaluate conditions:

```bash
test 1 -gt 0 ; echo $?      # 0 (true)
[[ 1 -eq 1 ]]; echo $?      # 0 (true)
```

> Note: Spaces inside brackets are mandatory:  `[ condition ]` not `[condition]`


**If-Then Statement**

Syntax: 
```bash
if CONDITION; then
    STATEMENT
fi
```

Example:
```bash
#!/usr/bin/bash
read -p "Guess the word: " guess
if [ "$guess" = "redhat" ]; then
    echo "You are correct! !"
fi
```

**If-Then-Else Statement**

Syntax: 
```bash
if CONDITION; then
    STATEMENT
else
    STATEMENT
fi
```

Example:
```bash
#!/usr/bin/bash
read -p "Guess the word: " guess
if [ "$guess" = "redhat" ]; then
    echo "You are correct!!"
else
    echo "Poor Guess, Try again! !"
fi
```

> **Note**: Spaces around brackets are mandatory:
> - Wrong: `["$guess"="redhat"]`
> - - Correct: `[ "$guess" = "redhat" ]`


**If-Then-Elif-Else Statement**

Syntax: 
```bash
if CONDITION1; then
    STATEMENT
elif CONDITION2; then
    STATEMENT
elif CONDITION3; then
    STATEMENT
else
    STATEMENT
fi
```

Example:
```bash
if [[ "$status" -eq 0 ]]; then
    echo "Success"
elif [[ "$status" -eq 1 ]]; then
    echo "Partial success"
else
    echo "Failure"
fi
```


**Case Statement**
  - Syntax (similar to switch in C):
```bash
case VARIABLE in
    pattern1)
        STATEMENT;;
    pattern2)
        STATEMENT;;
    *)
        STATEMENT;;
esac
```

Example:
```bash
#!/usr/bin/bash
read -p "Guess the word: " guess
case $guess in
    redhat)
        echo "Correct Guess! !";;
    centos)
        echo "Wrong Guess!!";;
    exit)
        poweroff;;
    *)
        echo "Not valid! !";;
esac
```

---

**Loops**

**- For Loop**

**Static List**

Syntax:
```bash
for VARIABLE in LIST; do
    COMMAND
done
```

Examples:
```bash
# Print numbers
for i in 1 2 3 4 5; do
    echo $i
done

# Using brace expansion
for HOST in host{1,2,3}; do
    echo $HOST
done

# Using range
for i in {1..10}; do
    echo $i
done

# Using seq command
for i in $(seq 1 10); do
    echo $i
done

# Using seq with step
for i in $(seq 0 5 100); do
    echo $i
done
```

**Dynamic List from User Input**

```bash
#!/usr/bin/bash
read -p "Enter names of your friends: " friends
echo "Your friends are:"
for frnd in $friends; do
    echo $frnd
done
```

**Iterating Over Files/Commands**

```bash
# Process each file
for file in *.txt; do
    echo "Processing $file"
done

# Process output of command
for package in $(rpm -qa | grep kernel); do
    echo $package
done
```

**While Loop**

Syntax:
```bash
while CONDITION; do
    STATEMENT
done
```

Executes as long as the condition is true (exit code 0):

```bash
#!/usr/bin/bash
num=1
while [ $num -le 3 ]; do
    read -p "Enter values of p, n, r: " p n r
    si=$(( (p * n * r) / 100 ))
    echo "Simple interest: $si"
    num=$((num + 1))
done
```

Example with counter:
```bash
x=1
while [[ $x -le 5 ]]; do
    echo "x is $x"
    x=$((x + 1))
done
```

**Until Loop**

Syntax:
```bash
until CONDITION; do
    STATEMENT
done
```

Executes as long as the condition is false (non-zero exit code):

```bash
x=5
until [[ $x -lt 1 ]]; do
    echo "x is $x"
    x=$((x - 1))
done
```

---

**Positional Parameters**
  - Positional parameters are variables used to pass arguments to a script when it is invoked. 

**Special Variables**

| Variable | Description |
|----------|-------------|
| `$0` | Script name (command used to invoke script) |
| `$1, $2, $3... ` | First, second, third arguments |
| `${10}, ${11}...` | 10th, 11th arguments (braces required for >9) |
| `$#` | Number of arguments passed (not counting $0) |
| `$*` | All arguments as a single string (deprecated) |
| `$@` | All arguments as separate strings |

>Notes:
>- Positional parameters > 9 must use braces: `${10}`
>- `$#` counts only arguments, not the script name ($0)
>- Use `"$@"` to properly preserve word boundaries in arguments
>- Use `$0` in usage messages for dynamic script name


**Examples**

- Printing Parameters
  - Script `params.sh`:
```bash
#!/usr/bin/bash
echo "Script name: $0"
echo "First argument: $1"
echo "Second argument: $2"
echo "All arguments: $*"
echo "All arguments (better): $@"
echo "Number of arguments: $#"
```

Execution:
```bash
./params.sh first second third
# Output:
# Script name: ./params.sh
# First argument: first
# Second argument: second
# All arguments: first second third
# All arguments (better): first second third
# Number of arguments: 3
```

**Using Positional Parameters**

Backup script: 
```bash
#!/usr/bin/bash
# Usage: ./mybackup.sh <source> <destination>
cp -r $1 $2
```

Usage:
```bash
./mybackup.sh /etc/*. conf /home/devops/backup1
./mybackup.sh /etc/passwd /home/devops/backup2
./mybackup.sh /etc /home/devops/backup3
```

---

**Functions**

**Creating Functions**

Syntax:
```bash
function_name() {
    STATEMENT
    ... 
    STATEMENT
}
```

Or alternative syntax:
```bash
function function_name {
    STATEMENT
}
```

**Calling Functions**

```bash
function_name          # Call function
function_name arg1 arg2 # Call with arguments
```

**Example Function**

```bash
#!/usr/bin/bash

# Define function
greet() {
    echo "Hello, $1!"
}

# Call function
greet "John"
greet "Jane"
```

**Functions with Return Values**

```bash
add() {
    local result=$((($1 + $2)))
    return $result
}

add 5 10
echo $?  # Get return value (0-255 range)
```

---

**Practical Examples**

**Calculator Script**

```bash
#!/usr/bin/bash
# Simple calculator using case statement

read -p "Enter first number: " num1
read -p "Enter second number: " num2
echo "Choose operation:"
echo "1. Addition"
echo "2. Subtraction"
echo "3. Multiplication"
echo "4. Division"

read -p "Enter choice (1-4): " choice

case $choice in
    1)
        result=$((num1 + num2))
        echo "Addition result: $result";;
    2)
        result=$((num1 - num2))
        echo "Subtraction result: $result";;
    3)
        result=$((num1 * num2))
        echo "Multiplication result: $result";;
    4)
        result=$((num1 / num2))
        echo "Division result:  $result";;
    *)
        echo "Invalid choice"
        exit 1;;
esac
```

>**Note**: For better mathematical calculations, use PERL instead of Bash Script. 

**File and Directory Checker**

```bash
#!/usr/bin/bash
# Script to check status of files/directories and display permissions

for i in *
do
    if [ !  -f $i ]; then
        echo "$i is not a normal file, it might be a directory"
    else
        if [ -r $i ] && [ -w $i ] && [ -x $i ]; then
            echo "$i is a normal file with full permissions"
        else
            echo "$i is a normal file without full permissions"
        fi
    fi
done
```

**Bulk User Creation**

```bash
#!/usr/bin/bash
# Script to add new users in bulk

# Prepare a file with usernames
# vim newstaff
# devops1
# devops2
# devops3

for new_user in $(cat /home/devops/newstaff); do
    useradd $new_user
    echo "Password123" | passwd --stdin $new_user
    chage -d 0 $new_user
    chage -m 1 -M 30 -W 2 -E 2027-01-01 $new_user
    echo "$new_user created successfully"
done
echo "All users successfully created!"
```

**Reading from Formatted File**

File format (newusers):
```
admin1:x:2001:2001:/home/admin1:/bin/bash
admin2:x:2002:2002:/home/admin2:/bin/bash
admin3:x:2003:2003:/home/admin3:/bin/bash
```

Script:
```bash
#!/usr/bin/bash
# Create users from formatted file

for new_user in $(cut -f 1 -d :  /home/devops/newusers); do
    useradd $new_user
    echo "Password123" | passwd --stdin $new_user
    chage -d 0 $new_user
    echo "$new_user created successfully!! !"
done
echo "All users successfully created! !"
```

**Bulk User Deletion**

```bash
#!/usr/bin/bash
# Script to delete multiple users

for del_user in $(cut -f 1 -d : /home/devops/newusers); do
    userdel -r $del_user
    echo "User $del_user deleted!"
done
echo "All users successfully deleted! !"
```

**Exit Status in Scripts**

Exit codes indicate script success or failure:
- Exit code `0` = Success
- Exit codes `1-255` = Failure

```bash
#!/usr/bin/bash
read -p "Guess the word: " guess

if [ "$guess" = "redhat" ]; then
    echo "You are correct!!"
    exit 0
else
    echo "Poor Guess, Try again! !"
    exit 1
fi
```

Check exit status:
```bash
./script.sh
echo $?  # Prints 0 for success, 1 for failure
```

**Setting and Sharing Directories**

```bash
# Create directory for sharing
cd /
mkdir dir_name

# Grant permissions to user
setfacl -m u:devops:rwx /dir_name

# Verify ACL
getfacl /dir_name
```

> **Note**: Normal users do not have write permission inside `/` directory. Only the root can create directories there and set permissions for other users.

---
